package persist

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"

	"github.com/cooperlutz/go-full/internal/pingpong/domain/entity"
	"github.com/cooperlutz/go-full/internal/pingpong/infra/persist/mapper"
	persist_postgres "github.com/cooperlutz/go-full/internal/pingpong/infra/persist/postgres"
	"github.com/cooperlutz/go-full/pkg/telemetree"
)

// FindAll - Query all pingpongs from DB and return a list of PingPongEntity.
func (r *PingPongPersistPostgresRepository) FindAll(ctx context.Context) (entity.ListOfPingPongs, error) {
	ctx, span := telemetree.AddSpan(ctx, "persist.postgres.findall")
	defer span.End()

	pingpongs, err := r.query.FindAll(ctx)
	if err != nil {
		return entity.ListOfPingPongs{}, err
	}

	result := mapper.MapFromDBPingPongs(pingpongs)

	return result, nil
}

// FindAllPings - Query all pings from the database and return them as a list of PingPongEntity.
func (r *PingPongPersistPostgresRepository) FindAllPings(ctx context.Context) (entity.ListOfPingPongs, error) {
	ctx, span := telemetree.AddSpan(ctx, "persist.postgres.findallpings")
	defer span.End()

	pingpongs, err := r.query.FindAllPing(ctx)
	if err != nil {
		return entity.ListOfPingPongs{}, err
	}

	result := mapper.MapFromDBPingPongs(pingpongs)

	return result, nil
}

// FindAllPongs - Query all pongs from the database and return them as a list of PingPongEntity.
func (r *PingPongPersistPostgresRepository) FindAllPongs(ctx context.Context) (entity.ListOfPingPongs, error) {
	ctx, span := telemetree.AddSpan(ctx, "persist.postgres.findallpongs")
	defer span.End()

	pingpongs, err := r.query.FindAllPong(ctx)
	if err != nil {
		return entity.ListOfPingPongs{}, err
	}

	result := mapper.MapFromDBPingPongs(pingpongs)

	return result, nil
}

/* STEP 2.4. Implement Repository Logic
we implement the relevant repository logic enabling us to pass in a uuid, and return an Entity
*/

// FindOneByID - Query the database for a pingpong based on its id.
func (r *PingPongPersistPostgresRepository) FindOneByID(ctx context.Context, id uuid.UUID) (entity.PingPongEntity, error) {
	// add a telemetry span
	ctx, span := telemetree.AddSpan(ctx, "persist.postgres.findonebyid")
	defer span.End()

	// now we need to convert the id to the param struct that needs to be provided to the
	// query function defined within the persistent postgres layer generated by sqlc
	queryParam := persist_postgres.FindOneByIDParams{
		PingpongID: pgtype.UUID{Bytes: id, Valid: true},
	}

	// create the pingpong object from the result of the query
	pingpong, err := r.query.FindOneByID(ctx, queryParam)
	if err != nil {
		// here we'll record the error within the telemetry span
		telemetree.RecordError(ctx, err, "unable to find pingpong with id"+id.String())

		return entity.PingPongEntity{}, err
	}

	// our `pingpong` is currently a persist_postgres.Pingpong, but our function needs to return an entity.PingPongEntity
	result := mapper.MapFromDB(pingpong)

	// finally, we can return the appropriate types as defined by our function
	return result, nil
}
