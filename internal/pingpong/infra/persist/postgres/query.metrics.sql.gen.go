// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.metrics.sql

package persist_postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPerDay = `-- name: CountPerDay :many
SELECT DATE(created_at) AS creation_date, COUNT(*) AS count_created
FROM pingpong
GROUP BY creation_date
ORDER BY creation_date ASC
`

type CountPerDayRow struct {
	CreationDate pgtype.Date `db:"creation_date" json:"creation_date"`
	CountCreated int64       `db:"count_created" json:"count_created"`
}

// CountPerDay
//
//	SELECT DATE(created_at) AS creation_date, COUNT(*) AS count_created
//	FROM pingpong
//	GROUP BY creation_date
//	ORDER BY creation_date ASC
func (q *Queries) CountPerDay(ctx context.Context) ([]CountPerDayRow, error) {
	rows, err := q.db.Query(ctx, countPerDay)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountPerDayRow
	for rows.Next() {
		var i CountPerDayRow
		if err := rows.Scan(&i.CreationDate, &i.CountCreated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const frequencyDistribution = `-- name: FrequencyDistribution :many
SELECT ping_or_pong, COUNT(*) AS frequency
FROM pingpong
GROUP BY ping_or_pong
ORDER BY frequency DESC
`

type FrequencyDistributionRow struct {
	PingOrPong pgtype.Text `db:"ping_or_pong" json:"ping_or_pong"`
	Frequency  int64       `db:"frequency" json:"frequency"`
}

// FrequencyDistribution
//
//	SELECT ping_or_pong, COUNT(*) AS frequency
//	FROM pingpong
//	GROUP BY ping_or_pong
//	ORDER BY frequency DESC
func (q *Queries) FrequencyDistribution(ctx context.Context) ([]FrequencyDistributionRow, error) {
	rows, err := q.db.Query(ctx, frequencyDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FrequencyDistributionRow
	for rows.Next() {
		var i FrequencyDistributionRow
		if err := rows.Scan(&i.PingOrPong, &i.Frequency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const frequencyDistributionByDay = `-- name: FrequencyDistributionByDay :many
SELECT DATE(created_at) AS creation_date, ping_or_pong, COUNT(*) AS frequency
FROM pingpong
GROUP BY creation_date, ping_or_pong
ORDER BY creation_date ASC, frequency DESC
`

type FrequencyDistributionByDayRow struct {
	CreationDate pgtype.Date `db:"creation_date" json:"creation_date"`
	PingOrPong   pgtype.Text `db:"ping_or_pong" json:"ping_or_pong"`
	Frequency    int64       `db:"frequency" json:"frequency"`
}

// FrequencyDistributionByDay
//
//	SELECT DATE(created_at) AS creation_date, ping_or_pong, COUNT(*) AS frequency
//	FROM pingpong
//	GROUP BY creation_date, ping_or_pong
//	ORDER BY creation_date ASC, frequency DESC
func (q *Queries) FrequencyDistributionByDay(ctx context.Context) ([]FrequencyDistributionByDayRow, error) {
	rows, err := q.db.Query(ctx, frequencyDistributionByDay)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FrequencyDistributionByDayRow
	for rows.Next() {
		var i FrequencyDistributionByDayRow
		if err := rows.Scan(&i.CreationDate, &i.PingOrPong, &i.Frequency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const frequencyDistributionByDayPing = `-- name: FrequencyDistributionByDayPing :many
SELECT DATE(created_at) AS creation_date, ping_or_pong AS ping, COUNT(*) AS frequency
FROM pingpong
WHERE ping = 'ping'
GROUP BY creation_date, ping
ORDER BY creation_date ASC, frequency DESC
`

type FrequencyDistributionByDayPingRow struct {
	CreationDate pgtype.Date `db:"creation_date" json:"creation_date"`
	Ping         pgtype.Text `db:"ping" json:"ping"`
	Frequency    int64       `db:"frequency" json:"frequency"`
}

// FrequencyDistributionByDayPing
//
//	SELECT DATE(created_at) AS creation_date, ping_or_pong AS ping, COUNT(*) AS frequency
//	FROM pingpong
//	WHERE ping = 'ping'
//	GROUP BY creation_date, ping
//	ORDER BY creation_date ASC, frequency DESC
func (q *Queries) FrequencyDistributionByDayPing(ctx context.Context) ([]FrequencyDistributionByDayPingRow, error) {
	rows, err := q.db.Query(ctx, frequencyDistributionByDayPing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FrequencyDistributionByDayPingRow
	for rows.Next() {
		var i FrequencyDistributionByDayPingRow
		if err := rows.Scan(&i.CreationDate, &i.Ping, &i.Frequency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const frequencyDistributionByDayPong = `-- name: FrequencyDistributionByDayPong :many
SELECT DATE(created_at) AS creation_date, ping_or_pong AS pong, COUNT(*) AS frequency
FROM pingpong
WHERE pong = 'pong'
GROUP BY creation_date, pong
ORDER BY creation_date ASC, frequency DESC
`

type FrequencyDistributionByDayPongRow struct {
	CreationDate pgtype.Date `db:"creation_date" json:"creation_date"`
	Pong         pgtype.Text `db:"pong" json:"pong"`
	Frequency    int64       `db:"frequency" json:"frequency"`
}

// FrequencyDistributionByDayPong
//
//	SELECT DATE(created_at) AS creation_date, ping_or_pong AS pong, COUNT(*) AS frequency
//	FROM pingpong
//	WHERE pong = 'pong'
//	GROUP BY creation_date, pong
//	ORDER BY creation_date ASC, frequency DESC
func (q *Queries) FrequencyDistributionByDayPong(ctx context.Context) ([]FrequencyDistributionByDayPongRow, error) {
	rows, err := q.db.Query(ctx, frequencyDistributionByDayPong)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FrequencyDistributionByDayPongRow
	for rows.Next() {
		var i FrequencyDistributionByDayPongRow
		if err := rows.Scan(&i.CreationDate, &i.Pong, &i.Frequency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalNumberOfPingPongs = `-- name: TotalNumberOfPingPongs :one
SELECT COUNT(*) FROM pingpong
`

// TotalNumberOfPingPongs
//
//	SELECT COUNT(*) FROM pingpong
func (q *Queries) TotalNumberOfPingPongs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalNumberOfPingPongs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const totalNumberOfPings = `-- name: TotalNumberOfPings :one
SELECT COUNT(*) FROM pingpong WHERE ping_or_pong = 'ping'
`

// TotalNumberOfPings
//
//	SELECT COUNT(*) FROM pingpong WHERE ping_or_pong = 'ping'
func (q *Queries) TotalNumberOfPings(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalNumberOfPings)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const totalNumberOfPongs = `-- name: TotalNumberOfPongs :one
SELECT COUNT(*) FROM pingpong WHERE ping_or_pong = 'pong'
`

// TotalNumberOfPongs
//
//	SELECT COUNT(*) FROM pingpong WHERE ping_or_pong = 'pong'
func (q *Queries) TotalNumberOfPongs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalNumberOfPongs)
	var count int64
	err := row.Scan(&count)
	return count, err
}
