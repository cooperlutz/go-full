// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.pingpong.sql

package persist_postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const findAll = `-- name: FindAll :many
SELECT pingpong_id, ping_or_pong, created_at, updated_at, deleted_at, deleted
FROM pingpong
`

// FindAll
//
//	SELECT pingpong_id, ping_or_pong, created_at, updated_at, deleted_at, deleted
//	FROM pingpong
func (q *Queries) FindAll(ctx context.Context) ([]Pingpong, error) {
	rows, err := q.db.Query(ctx, findAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pingpong
	for rows.Next() {
		var i Pingpong
		if err := rows.Scan(
			&i.PingpongID,
			&i.PingOrPong,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllPing = `-- name: FindAllPing :many
SELECT pingpong_id, ping_or_pong, created_at, updated_at, deleted_at, deleted
FROM pingpong
WHERE ping_or_pong = 'ping'
`

// FindAllPing
//
//	SELECT pingpong_id, ping_or_pong, created_at, updated_at, deleted_at, deleted
//	FROM pingpong
//	WHERE ping_or_pong = 'ping'
func (q *Queries) FindAllPing(ctx context.Context) ([]Pingpong, error) {
	rows, err := q.db.Query(ctx, findAllPing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pingpong
	for rows.Next() {
		var i Pingpong
		if err := rows.Scan(
			&i.PingpongID,
			&i.PingOrPong,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllPong = `-- name: FindAllPong :many
SELECT pingpong_id, ping_or_pong, created_at, updated_at, deleted_at, deleted FROM pingpong
WHERE ping_or_pong = 'pong'
`

// FindAllPong
//
//	SELECT pingpong_id, ping_or_pong, created_at, updated_at, deleted_at, deleted FROM pingpong
//	WHERE ping_or_pong = 'pong'
func (q *Queries) FindAllPong(ctx context.Context) ([]Pingpong, error) {
	rows, err := q.db.Query(ctx, findAllPong)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pingpong
	for rows.Next() {
		var i Pingpong
		if err := rows.Scan(
			&i.PingpongID,
			&i.PingOrPong,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOneByID = `-- name: FindOneByID :one
/* STEP 2.1. Implement Data Access Layer
- Write the associated sql logic in accordance with the specifics defined in SQLC
- once defined, run ` + "`" + `make queries` + "`" + `, this will run sqlc and generate the relevant Go code
*/

SELECT pingpong_id, ping_or_pong, created_at, updated_at, deleted_at, deleted
FROM pingpong
WHERE pingpong_id = $1
`

type FindOneByIDParams struct {
	PingpongID pgtype.UUID `db:"pingpong_id" json:"pingpong_id"`
}

// FindOneByID
//
//	/* STEP 2.1. Implement Data Access Layer
//	- Write the associated sql logic in accordance with the specifics defined in SQLC
//	- once defined, run `make queries`, this will run sqlc and generate the relevant Go code
//	*/
//
//	SELECT pingpong_id, ping_or_pong, created_at, updated_at, deleted_at, deleted
//	FROM pingpong
//	WHERE pingpong_id = $1
func (q *Queries) FindOneByID(ctx context.Context, arg FindOneByIDParams) (Pingpong, error) {
	row := q.db.QueryRow(ctx, findOneByID, arg.PingpongID)
	var i Pingpong
	err := row.Scan(
		&i.PingpongID,
		&i.PingOrPong,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
	)
	return i, err
}
