// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: postgres_queries.sql

package outbound

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addExam = `-- name: AddExam :exec
INSERT INTO examination.exams (
    exam_id,
    created_at,
    updated_at,
    deleted_at,
    deleted,
    student_id,
    library_exam_id,
    state,
    completed_at,
    started_at,
    time_limit,
    time_of_time_limit
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
)
`

type AddExamParams struct {
	ExamID          pgtype.UUID        `db:"exam_id" json:"exam_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	Deleted         bool               `db:"deleted" json:"deleted"`
	StudentID       pgtype.UUID        `db:"student_id" json:"student_id"`
	LibraryExamID   pgtype.UUID        `db:"library_exam_id" json:"library_exam_id"`
	State           string             `db:"state" json:"state"`
	CompletedAt     pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	StartedAt       pgtype.Timestamptz `db:"started_at" json:"started_at"`
	TimeLimit       int64              `db:"time_limit" json:"time_limit"`
	TimeOfTimeLimit pgtype.Timestamptz `db:"time_of_time_limit" json:"time_of_time_limit"`
}

// AddExam
//
//	INSERT INTO examination.exams (
//	    exam_id,
//	    created_at,
//	    updated_at,
//	    deleted_at,
//	    deleted,
//	    student_id,
//	    library_exam_id,
//	    state,
//	    completed_at,
//	    started_at,
//	    time_limit,
//	    time_of_time_limit
//	) VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7,
//	    $8,
//	    $9,
//	    $10,
//	    $11,
//	    $12
//	)
func (q *Queries) AddExam(ctx context.Context, arg AddExamParams) error {
	_, err := q.db.Exec(ctx, addExam,
		arg.ExamID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.Deleted,
		arg.StudentID,
		arg.LibraryExamID,
		arg.State,
		arg.CompletedAt,
		arg.StartedAt,
		arg.TimeLimit,
		arg.TimeOfTimeLimit,
	)
	return err
}

const addQuestion = `-- name: AddQuestion :exec
INSERT INTO examination.questions (
    question_id,
    created_at,
    updated_at,
    deleted_at,
    deleted,
    exam_id,
    index,
    answered,
    question_text,
    question_type,
    provided_answer,
    response_options
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
)
`

type AddQuestionParams struct {
	QuestionID      pgtype.UUID        `db:"question_id" json:"question_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	Deleted         bool               `db:"deleted" json:"deleted"`
	ExamID          pgtype.UUID        `db:"exam_id" json:"exam_id"`
	Index           int32              `db:"index" json:"index"`
	Answered        bool               `db:"answered" json:"answered"`
	QuestionText    string             `db:"question_text" json:"question_text"`
	QuestionType    string             `db:"question_type" json:"question_type"`
	ProvidedAnswer  pgtype.Text        `db:"provided_answer" json:"provided_answer"`
	ResponseOptions []string           `db:"response_options" json:"response_options"`
}

// AddQuestion
//
//	INSERT INTO examination.questions (
//	    question_id,
//	    created_at,
//	    updated_at,
//	    deleted_at,
//	    deleted,
//	    exam_id,
//	    index,
//	    answered,
//	    question_text,
//	    question_type,
//	    provided_answer,
//	    response_options
//	) VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7,
//	    $8,
//	    $9,
//	    $10,
//	    $11,
//	    $12
//	)
func (q *Queries) AddQuestion(ctx context.Context, arg AddQuestionParams) error {
	_, err := q.db.Exec(ctx, addQuestion,
		arg.QuestionID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.Deleted,
		arg.ExamID,
		arg.Index,
		arg.Answered,
		arg.QuestionText,
		arg.QuestionType,
		arg.ProvidedAnswer,
		arg.ResponseOptions,
	)
	return err
}

const findAllExams = `-- name: FindAllExams :many
SELECT exam_id, created_at, updated_at, deleted_at, deleted, student_id, library_exam_id, state, completed_at, started_at, time_limit, time_of_time_limit FROM examination.exams
`

// FindAllExams
//
//	SELECT exam_id, created_at, updated_at, deleted_at, deleted, student_id, library_exam_id, state, completed_at, started_at, time_limit, time_of_time_limit FROM examination.exams
func (q *Queries) FindAllExams(ctx context.Context) ([]ExaminationExam, error) {
	rows, err := q.db.Query(ctx, findAllExams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExaminationExam
	for rows.Next() {
		var i ExaminationExam
		if err := rows.Scan(
			&i.ExamID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.StudentID,
			&i.LibraryExamID,
			&i.State,
			&i.CompletedAt,
			&i.StartedAt,
			&i.TimeLimit,
			&i.TimeOfTimeLimit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findQuestionsForExam = `-- name: FindQuestionsForExam :many
SELECT question_id, created_at, updated_at, deleted_at, deleted, exam_id, index, answered, question_text, question_type, provided_answer, response_options FROM examination.questions
WHERE exam_id = $1
`

type FindQuestionsForExamParams struct {
	ExamID pgtype.UUID `db:"exam_id" json:"exam_id"`
}

// FindQuestionsForExam
//
//	SELECT question_id, created_at, updated_at, deleted_at, deleted, exam_id, index, answered, question_text, question_type, provided_answer, response_options FROM examination.questions
//	WHERE exam_id = $1
func (q *Queries) FindQuestionsForExam(ctx context.Context, arg FindQuestionsForExamParams) ([]ExaminationQuestion, error) {
	rows, err := q.db.Query(ctx, findQuestionsForExam, arg.ExamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExaminationQuestion
	for rows.Next() {
		var i ExaminationQuestion
		if err := rows.Scan(
			&i.QuestionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.ExamID,
			&i.Index,
			&i.Answered,
			&i.QuestionText,
			&i.QuestionType,
			&i.ProvidedAnswer,
			&i.ResponseOptions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExam = `-- name: GetExam :one
SELECT exam_id, created_at, updated_at, deleted_at, deleted, student_id, library_exam_id, state, completed_at, started_at, time_limit, time_of_time_limit FROM examination.exams
WHERE exam_id = $1
`

type GetExamParams struct {
	ExamID pgtype.UUID `db:"exam_id" json:"exam_id"`
}

// GetExam
//
//	SELECT exam_id, created_at, updated_at, deleted_at, deleted, student_id, library_exam_id, state, completed_at, started_at, time_limit, time_of_time_limit FROM examination.exams
//	WHERE exam_id = $1
func (q *Queries) GetExam(ctx context.Context, arg GetExamParams) (ExaminationExam, error) {
	row := q.db.QueryRow(ctx, getExam, arg.ExamID)
	var i ExaminationExam
	err := row.Scan(
		&i.ExamID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
		&i.StudentID,
		&i.LibraryExamID,
		&i.State,
		&i.CompletedAt,
		&i.StartedAt,
		&i.TimeLimit,
		&i.TimeOfTimeLimit,
	)
	return i, err
}

const getQuestion = `-- name: GetQuestion :one
SELECT question_id, created_at, updated_at, deleted_at, deleted, exam_id, index, answered, question_text, question_type, provided_answer, response_options FROM examination.questions
WHERE question_id = $1
`

type GetQuestionParams struct {
	QuestionID pgtype.UUID `db:"question_id" json:"question_id"`
}

// GetQuestion
//
//	SELECT question_id, created_at, updated_at, deleted_at, deleted, exam_id, index, answered, question_text, question_type, provided_answer, response_options FROM examination.questions
//	WHERE question_id = $1
func (q *Queries) GetQuestion(ctx context.Context, arg GetQuestionParams) (ExaminationQuestion, error) {
	row := q.db.QueryRow(ctx, getQuestion, arg.QuestionID)
	var i ExaminationQuestion
	err := row.Scan(
		&i.QuestionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
		&i.ExamID,
		&i.Index,
		&i.Answered,
		&i.QuestionText,
		&i.QuestionType,
		&i.ProvidedAnswer,
		&i.ResponseOptions,
	)
	return i, err
}

const getQuestionByExamAndIndex = `-- name: GetQuestionByExamAndIndex :one
SELECT question_id, created_at, updated_at, deleted_at, deleted, exam_id, index, answered, question_text, question_type, provided_answer, response_options FROM examination.questions
WHERE exam_id = $1 AND index = $2
`

type GetQuestionByExamAndIndexParams struct {
	ExamID pgtype.UUID `db:"exam_id" json:"exam_id"`
	Index  int32       `db:"index" json:"index"`
}

// GetQuestionByExamAndIndex
//
//	SELECT question_id, created_at, updated_at, deleted_at, deleted, exam_id, index, answered, question_text, question_type, provided_answer, response_options FROM examination.questions
//	WHERE exam_id = $1 AND index = $2
func (q *Queries) GetQuestionByExamAndIndex(ctx context.Context, arg GetQuestionByExamAndIndexParams) (ExaminationQuestion, error) {
	row := q.db.QueryRow(ctx, getQuestionByExamAndIndex, arg.ExamID, arg.Index)
	var i ExaminationQuestion
	err := row.Scan(
		&i.QuestionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Deleted,
		&i.ExamID,
		&i.Index,
		&i.Answered,
		&i.QuestionText,
		&i.QuestionType,
		&i.ProvidedAnswer,
		&i.ResponseOptions,
	)
	return i, err
}

const getQuestionsByExam = `-- name: GetQuestionsByExam :many
SELECT question_id, created_at, updated_at, deleted_at, deleted, exam_id, index, answered, question_text, question_type, provided_answer, response_options FROM examination.questions
WHERE exam_id = $1
ORDER BY index ASC
`

type GetQuestionsByExamParams struct {
	ExamID pgtype.UUID `db:"exam_id" json:"exam_id"`
}

// GetQuestionsByExam
//
//	SELECT question_id, created_at, updated_at, deleted_at, deleted, exam_id, index, answered, question_text, question_type, provided_answer, response_options FROM examination.questions
//	WHERE exam_id = $1
//	ORDER BY index ASC
func (q *Queries) GetQuestionsByExam(ctx context.Context, arg GetQuestionsByExamParams) ([]ExaminationQuestion, error) {
	rows, err := q.db.Query(ctx, getQuestionsByExam, arg.ExamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExaminationQuestion
	for rows.Next() {
		var i ExaminationQuestion
		if err := rows.Scan(
			&i.QuestionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Deleted,
			&i.ExamID,
			&i.Index,
			&i.Answered,
			&i.QuestionText,
			&i.QuestionType,
			&i.ProvidedAnswer,
			&i.ResponseOptions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveExam = `-- name: SaveExam :exec
UPDATE examination.exams
SET
    created_at = $2,
    updated_at = $3,
    deleted_at = $4,
    deleted = $5,
    student_id = $6,
    library_exam_id = $7,
    state = $8,
    completed_at = $9,
    started_at = $10,
    time_limit = $11,
    time_of_time_limit = $12
WHERE exam_id = $1
`

type SaveExamParams struct {
	ExamID          pgtype.UUID        `db:"exam_id" json:"exam_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	Deleted         bool               `db:"deleted" json:"deleted"`
	StudentID       pgtype.UUID        `db:"student_id" json:"student_id"`
	LibraryExamID   pgtype.UUID        `db:"library_exam_id" json:"library_exam_id"`
	State           string             `db:"state" json:"state"`
	CompletedAt     pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	StartedAt       pgtype.Timestamptz `db:"started_at" json:"started_at"`
	TimeLimit       int64              `db:"time_limit" json:"time_limit"`
	TimeOfTimeLimit pgtype.Timestamptz `db:"time_of_time_limit" json:"time_of_time_limit"`
}

// SaveExam
//
//	UPDATE examination.exams
//	SET
//	    created_at = $2,
//	    updated_at = $3,
//	    deleted_at = $4,
//	    deleted = $5,
//	    student_id = $6,
//	    library_exam_id = $7,
//	    state = $8,
//	    completed_at = $9,
//	    started_at = $10,
//	    time_limit = $11,
//	    time_of_time_limit = $12
//	WHERE exam_id = $1
func (q *Queries) SaveExam(ctx context.Context, arg SaveExamParams) error {
	_, err := q.db.Exec(ctx, saveExam,
		arg.ExamID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.Deleted,
		arg.StudentID,
		arg.LibraryExamID,
		arg.State,
		arg.CompletedAt,
		arg.StartedAt,
		arg.TimeLimit,
		arg.TimeOfTimeLimit,
	)
	return err
}

const saveQuestion = `-- name: SaveQuestion :exec
UPDATE examination.questions
SET
    created_at = $2,
    updated_at = $3,
    deleted_at = $4,
    deleted = $5,
    exam_id = $6,
    index = $7,
    answered = $8,
    question_text = $9,
    question_type = $10,
    provided_answer = $11,
    response_options = $12
WHERE question_id = $1
`

type SaveQuestionParams struct {
	QuestionID      pgtype.UUID        `db:"question_id" json:"question_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	Deleted         bool               `db:"deleted" json:"deleted"`
	ExamID          pgtype.UUID        `db:"exam_id" json:"exam_id"`
	Index           int32              `db:"index" json:"index"`
	Answered        bool               `db:"answered" json:"answered"`
	QuestionText    string             `db:"question_text" json:"question_text"`
	QuestionType    string             `db:"question_type" json:"question_type"`
	ProvidedAnswer  pgtype.Text        `db:"provided_answer" json:"provided_answer"`
	ResponseOptions []string           `db:"response_options" json:"response_options"`
}

// SaveQuestion
//
//	UPDATE examination.questions
//	SET
//	    created_at = $2,
//	    updated_at = $3,
//	    deleted_at = $4,
//	    deleted = $5,
//	    exam_id = $6,
//	    index = $7,
//	    answered = $8,
//	    question_text = $9,
//	    question_type = $10,
//	    provided_answer = $11,
//	    response_options = $12
//	WHERE question_id = $1
func (q *Queries) SaveQuestion(ctx context.Context, arg SaveQuestionParams) error {
	_, err := q.db.Exec(ctx, saveQuestion,
		arg.QuestionID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.Deleted,
		arg.ExamID,
		arg.Index,
		arg.Answered,
		arg.QuestionText,
		arg.QuestionType,
		arg.ProvidedAnswer,
		arg.ResponseOptions,
	)
	return err
}
