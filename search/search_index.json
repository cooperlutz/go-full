{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Go Full","text":"<p>Go Full is a full-stack project boilerplate template, learning tool, and reference implementation demonstrating a variety of development patterns and practices.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>In the movie, Ratatouille, the late Chef Gusteau has a saying that serves as a core theme of the film; \"anyone can cook\". Recently, AI Coding, Vibe Coding, and the like, have taken off and shifted the pardigm of development toward extremely fast, hands-off, AI developing AI, and various other rabbit holes. Ironically, the concepts and capabilities that AI Code Generation promise aren't necessarily all that new... code generation tools have been around since, well forever, as have low-code or no-code tools. At the end of the day, what matters most is the adoption, value, and functionality of the system being developed, along with the maintainability of the code that makes up the system.</p> <p>Many higher level tools take away flexibility (and the fun) of development. Oftentimes, complex packages and libraries can abstract away an understanding of what/how/why the system does what it does. This project intends not to abstract away core functinality with light and intentional usage of more basic packages (not fully functional highly opinionated frameworks).</p> <p>This project aims to provide a well-formed, \"just enough\" featured, minimalist boilerplate examplar under the idea that \"anyone can code\". And with that, we don't want to just spit out code that works (or looks like it works) as quickly as tokens could possibly be consumed, we instead focus on providing the components and resources to develop applications or services in a manner that prioritizes developers truly understanding the why, what, and how behind the things they are developing and making industry terminolgy and Buzzwords more real. We leverage code generation tools (mockery, oapi code generators, sqlc) to reduce boilerplate code development. Regardless of what is developed by hand or machine utilizing this project, the intent is to prioritize code quality over quantity, or more commonly, Clean Code along with Product quality.</p>"},{"location":"#priorities-decision-criteria","title":"Priorities &amp; Decision Criteria","text":"<ul> <li>Anyone can code</li> <li>Code and Feature Quality</li> <li>Go as a first class citizen</li> <li>Development focus and emphasis should be on the domain logic and user features</li> <li>Development should be fun!</li> <li>Semantic &amp; Idiomatic code and tools</li> <li>Tools should be configuration-based via yaml</li> <li>Languages should be typesafe</li> <li>Everything as code</li> <li>not overengineered, but smart and scalable</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>[!WARNING] This project has only been tested for development on macOS</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Git</li> <li>Make</li> <li>Docker</li> <li>Docker Compose</li> <li>Brew</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/cooperlutz/go-full.git\n\n# Change directory to the project folder\ncd go-full\n\n# run make init to initialize and run the project\nmake init\n</code></pre> <p>Then open your browser to <code>http://app.lvh.me</code> to see the running application</p>"},{"location":"#additional-helpful-development-commands","title":"Additional Helpful Development Commands","text":"<pre><code>make # end to end development tools\n\nmake compose # builds, deploys, and runs development environment\n\nmake commit # provides a mechanism to simplify conventional commits\n</code></pre> <p>For further details, please consult our docs</p>"},{"location":"decisions/","title":"Decisions","text":"<p>We document decisions as Architecture Decision Records, leveraging the format as defined and popularized by Michael Nygard. However, we are interpreting and adapting the concept of ADRs beyond strictly architecture, and making documented decisions inclusive of implementations and / or other relevant decisions that are worthy of documenting. ADRs provide a simple and concise format and its generally good practice to document decisions and the decision making process in just about any context.</p> <p>We have also adapted the base ADR template to better suit our needs. See below for the adapted template we use.</p>"},{"location":"decisions/#adr-template","title":"ADR Template","text":"<pre><code># [00000]: Title of the Decision\n\n## Status\n\n[e.g., Proposed, Accepted, Rejected, Deprecated, Superseded by ADR-XXX]\n\n## Context\n\nDescribe the issue or problem that prompted this architectural decision. What are the driving forces, requirements, or constraints that led to the need for a decision?\n\n## Decision\n\nClearly state the chosen architectural decision. Explain what was decided and why this specific option was chosen.\n\n### Implementation\n\nIf applicable, outline relevant implementation decisions, steps, or considerations that arise from this architectural decision, along with supporting considerations to support the decision.\n\n## Alternatives Considered\n\nList and briefly describe the alternative options that were explored but ultimately not selected. Provide a brief rationale for why each alternative was rejected.\n\n## Consequences\n\nDetail the implications of this decision. What are the positive and negative impacts? What becomes easier or more difficult as a result of this change? Consider impacts on development, operations, maintenance, performance, security, and other relevant aspects.\n</code></pre>"},{"location":"decisions/00001_core/","title":"00001: Core Logic","text":""},{"location":"decisions/00001_core/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/00001_core/#context","title":"Context","text":"<p>Within the context of the overall system being developed, a programming language is required to support our core logic and the application implementation of the system.</p>"},{"location":"decisions/00001_core/#decision","title":"Decision","text":"<p>Go will be used as the programming language for the core logic and application implementation of the system.</p>"},{"location":"decisions/00001_core/#alternatives-considered","title":"Alternatives Considered","text":"<p>None.</p>"},{"location":"decisions/00001_core/#consequences","title":"Consequences","text":"<p>The decision to use Go will have several consequences:</p> <ul> <li>Performance: Go is known for its high performance, especially with concurrency support through goroutines</li> <li>Type Safety: Go is a statically typed language, which helps catch errors at compile time and improves code reliability.</li> <li>Simplicity: Go's syntax is simple and easy to understand, which will help in maintaining the codebase and onboarding new developers.</li> <li>Community: Go has a strong and active community, which means we can easily find support, resources, and best practices.</li> </ul>"},{"location":"decisions/00002_system_arch/","title":"00002: System Architecture","text":""},{"location":"decisions/00002_system_arch/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/00002_system_arch/#context","title":"Context","text":"<p>In context of developing the system, a general architectural approach needs to be defined. This decision will guide the overall project development.</p>"},{"location":"decisions/00002_system_arch/#decision","title":"Decision","text":"<p>The chosen architectural decision is to adopt a modular monolith architecture, adhering to principles of Domain-Driven Design (DDD).</p>"},{"location":"decisions/00002_system_arch/#implementation","title":"Implementation","text":"<ul> <li>System Modules will be defined based on bounded contexts identified through Domain-Driven Design practices.</li> <li>Each module will be encapsulated across each layer of the application (e.g., presentation, application, domain, infrastructure) and be capable of being extended, removed, or replaced with minimal impact to other modules.</li> </ul>"},{"location":"decisions/00002_system_arch/#alternatives-considered","title":"Alternatives Considered","text":"<ul> <li>Microservices: While microservices offer scalability and independent deployment, they introduce significant complexity in terms of inter-service communication, data consistency, and operational overhead. Given the current project scope, this complexity is unwarranted.</li> </ul>"},{"location":"decisions/00002_system_arch/#consequences","title":"Consequences","text":"<p>If the system were to need improved scalability, highly complex logic within an individual module, or require independent deployment cycles for different parts of the system, a shift to microservices architecture may be reconsidered.</p>"},{"location":"decisions/00003_data_persistence/","title":"00003: Data Persistence","text":""},{"location":"decisions/00003_data_persistence/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/00003_data_persistence/#context","title":"Context","text":"<p>In the context of the overall system, persistent data storage will be required to store data. This decision influences and directly impacts development complexity, tooling, and system performance.</p>"},{"location":"decisions/00003_data_persistence/#decision","title":"Decision","text":"<p>The chosen approach for data persistence is to use a relational database management system (RDBMS) for structured data storage, leveraging its ACID properties to ensure data integrity and consistency. This decision was made to align with the project's requirements for complex querying and reporting.</p>"},{"location":"decisions/00003_data_persistence/#implementation","title":"Implementation","text":"<ul> <li>Database Schema Design: The database schema will be designed to reflect the domain model, ensuring that tables and relationships align with the application's requirements. Each module will have its own schema to encapsulate its data.</li> <li>ORM Usage: An Object-Relational Mapping (ORM) tool will NOT be used. Instead, direct SQL queries will be employed to interact with the database, providing greater control over query optimization and performance tuning. These queries will be defined and generated via sqlc</li> <li>PostgreSQL has been selected as the specific RDBMS.</li> </ul>"},{"location":"decisions/00003_data_persistence/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"decisions/00003_data_persistence/#storage-options","title":"Storage Options","text":"<ul> <li>NoSQL Databases: While NoSQL databases offer flexibility in handling unstructured data and can scale horizontally, they may lack the robust transactional support required for this project. Given the current data requirements, the complexity introduced by NoSQL systems is not justified.</li> <li>In-Memory Databases: Although in-memory databases provide high-speed data access, they are not suitable for long-term data persistence due to volatility.</li> <li>Flat File Storage: While flat file storage is simple to implement, it lacks the advanced querying capabilities and data integrity features provided by RDBMS. This option was rejected due to scalability and performance concerns.</li> </ul>"},{"location":"decisions/00003_data_persistence/#database-management-systems","title":"Database Management Systems","text":"<ul> <li>SQLite: While SQLite is lightweight and easy to set up, it is not suitable for applications requiring concurrent access by multiple users or high transaction volumes. Further, it would limit future scalability options.</li> </ul>"},{"location":"decisions/00003_data_persistence/#consequences","title":"Consequences","text":"<p>As a consequence of this decision:</p> <ul> <li>Increased complexity to maintain the postgres database server</li> <li>Need to manage database migrations and versioning</li> <li>Improved data integrity and consistency</li> </ul>"},{"location":"decisions/00004_frontend/","title":"00004: Frontend User Interface (UI)","text":""},{"location":"decisions/00004_frontend/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/00004_frontend/#context","title":"Context","text":"<p>In order for the project to be considered a \"full stack\", a user interface is a necessity</p>"},{"location":"decisions/00004_frontend/#decision","title":"Decision","text":"<p>The Frontend UI will be developed as a Single Page Application in Vue and compiled to a SPA, which is ultimately embedded in Go. Further, we will aim to minimize the amount of javascript/typescript code utilized in the development of the frontend.</p> <p>This decision was made based on the following considerations:</p> <ul> <li>Vue is lightweight and more easily translated to another framework if needed.</li> <li>Vue has a smaller learning curve compared to React</li> <li>Vue's Templates are more HTML centric</li> <li>Vue can utilize React components, if desired.</li> <li>Vue can utilize basic HTML/CSS/JS if desired.</li> <li>Utilizing openapi-generator we can define an openapi specification and generate the a typescript client that the frontend can consume and expose within Vue composables.</li> </ul>"},{"location":"decisions/00004_frontend/#alternatives-considered","title":"Alternatives Considered","text":"<ul> <li>HTML Templates w/ HTMX: Go's html/template package could be utilized to render server side HTML templates. However, unless we were to utilize and implement HTMX a fair amount of JavaScript would be required to achieve the desired interactivity. Further, there are far fewer points of reference and examples for this approach.</li> <li>Vue w/ Nuxt SSR: this solution would require additional java/typescript code which we are trying to minimize.</li> <li>React SPA: React can get bloated and requires a significant amount of java/typescript, which we are trying to minimize.</li> </ul>"},{"location":"decisions/00004_frontend/#consequences","title":"Consequences","text":"<ul> <li>additional development effort will be required in order to handle integrations between the frontend and backend</li> <li>A programmatic client will need to be developed to support communication between the frontend and backend</li> </ul>"},{"location":"decisions/00005_programming_interface/","title":"00005: Initial Application Programming Interface","text":""},{"location":"decisions/00005_programming_interface/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/00005_programming_interface/#context","title":"Context","text":"<p>In order to enable programmatic access to the core / backend, an interface needs to be exposed.</p>"},{"location":"decisions/00005_programming_interface/#decision","title":"Decision","text":"<p>The initial programming interface will be a RESTful API adhering to OpenAPI specifications. The OpenAPI specification will be utilized to generate go server code for the backend, go client code which can be used for e2e tests and other go based clients, and a typescript client which can be used by the frontend.</p>"},{"location":"decisions/00005_programming_interface/#alternatives-considered","title":"Alternatives Considered","text":"<ul> <li>GraphQL</li> <li>gRPC</li> </ul>"},{"location":"decisions/00005_programming_interface/#consequences","title":"Consequences","text":"<p>The OpenAPI specification will need to be maintained as the system evolves. The OpenAPI specification will drive much of the development of the system as it will be used to generate significant portions of code for both the backend and frontend.</p>"},{"location":"decisions/00006_base_design_system/","title":"00006: Design System Basis","text":""},{"location":"decisions/00006_base_design_system/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/00006_base_design_system/#context","title":"Context","text":"<p>For the purposes of the frontend user interface, a component &amp; styling is required.</p>"},{"location":"decisions/00006_base_design_system/#decision","title":"Decision","text":"<p>TailwindCSS along with DaisyUi were chosen to serve as the basis for the design system. TailwindCSS has a strong ecosystem and many readily available reference points to support frontend development.</p> <p>DaisyUi has gained a strong following and is incredibly semantic in nature. DaisyUi is also highly portable if the frontend were to be ported to React / HTML / svelte / other. DaisyUi also provides the ability to extend, override, or ignore syling of various components or themes as needed.</p>"},{"location":"decisions/00006_base_design_system/#alternatives-considered","title":"Alternatives Considered","text":"<ul> <li>Shadcn: while incredibly popular, if not currently the most popular, shadcn requires a fair amount of java/type scripting and is heavily react centric.</li> <li>Vuetify: is more complex and vue centric, making portability more difficult.</li> <li>PrimeVue: is more complex and vue centric, making portability more difficult.</li> <li>Material: Material Design has a strong following, but its implementation can be verbose and may not fit well with the desired aesthetic.</li> <li>Bootstrap: while widely used and easy to implement, Bootstrap's default styles may not provide the level of customization needed for the project.</li> </ul>"},{"location":"decisions/00006_base_design_system/#consequences","title":"Consequences","text":"<ul> <li>Developers will need to familiarize themselves with TailwindCSS and DaisyUi conventions.</li> <li>The design system will be more easily portable to other frontend frameworks if needed in the future.</li> </ul>"},{"location":"decisions/00007_releases/","title":"00007: Releases","text":""},{"location":"decisions/00007_releases/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/00007_releases/#context","title":"Context","text":"<p>In the context of releasing code, a mechanism to track and document releases is essential. This decision outlines the approach for managing releases, including versioning, changelogs, and distribution methods.</p>"},{"location":"decisions/00007_releases/#decision","title":"Decision","text":"<p>The decision is to adopt semantic versioning (SemVer) for versioning, maintain a detailed changelog in the repository, and use Git tags to mark release points. Release distributions and packages will be managed via Github Releases.</p>"},{"location":"decisions/00007_releases/#implementation","title":"Implementation","text":"<ul> <li>Commitizen will handle conventional commit messages to automate versioning and changelog generation.</li> <li>GoReleaser will be used to automate the build and release process, ensuring consistent and reproducible releases.</li> <li>Releases will be documented in a <code>CHANGELOG.md</code> file, following the \"Keep a Changelog\" format. This will be implemented via Commitizen.</li> <li>Git tags will be created for each release, following the SemVer format (e.g., v1.0.0). Commitizen will handle tag creation.</li> <li>Github Actions will handle orchestration of the release process, integrating with GoReleaser for building and publishing releases.</li> <li>Releases will be triggered upon merging to the main branch, without utilizing release branches.</li> </ul>"},{"location":"decisions/00007_releases/#alternatives-considered","title":"Alternatives Considered","text":"<p>Release branches were considered and initially implemented but were ultimately removed in favor of a more streamlined approach that is more aligned to Trunk Based Development.</p>"},{"location":"decisions/00007_releases/#consequences","title":"Consequences","text":"<ul> <li>Development Flow is streamlined by removing the need to manage release branches, changelogs and automated versioning.</li> <li>Releases are more frequent and easier to manage, reducing overhead and complexity in the release process.</li> <li>All merges to <code>main</code> should be considered fully functional code, as they will directly trigger releases that could be consumed by end users.</li> <li>Exceptions may be required in situations when merging to main without triggering a release is required, and will need to be solutioned for.</li> </ul>"},{"location":"decisions/00008_dev_env/","title":"00008: Development Environment","text":""},{"location":"decisions/00008_dev_env/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"decisions/00008_dev_env/#context","title":"Context","text":"<p>In the context of Development of the system, a consistent environment is required in order to ensure the system is reproducible.</p>"},{"location":"decisions/00008_dev_env/#decision","title":"Decision","text":"<p>The decision was made to utilize Docker &amp; Docker Compose on developer workstations in order to provide consistency</p>"},{"location":"decisions/00008_dev_env/#implementation","title":"Implementation","text":"<p>Hardware: Local Workstation Platform: MacOS Assumed Tooling: installed to local workstation via brew Deployment Configuration &amp; Orchestration: Docker Compose</p>"},{"location":"decisions/00008_dev_env/#alternatives-considered","title":"Alternatives Considered","text":"<ul> <li>Local K8s implementation (kind, minikube): these solutions would more effectively scale under the assumption that the 'production' deployment is running within a k8s cluster, however it also adds additional complexity and requires further development. Ultimately, docker compose is lighter weight and simpler to implement and suits our current needs, and enables us to shift toward a local k8s if and when the need presents itself.</li> </ul>"},{"location":"decisions/00008_dev_env/#consequences","title":"Consequences","text":"<ul> <li>There are limitations with utilizing Postgres in containers, which could result in issues when running the application in production database servers.</li> <li>The current solution does not provide support for Windows Desktop OS, but given a majority of functionality is containerized, support can be added at a later point in time.</li> </ul>"},{"location":"development/","title":"Software Development Lifecycle","text":""},{"location":"development/#developing","title":"Developing","text":""},{"location":"development/branching/","title":"Branching Strategy","text":"<p>We follow Trunk Based Development practices, enforcing and encouraging short-lived feature branches that are continuously merged into <code>main</code> (trunk).</p> <p></p>"},{"location":"development/building/","title":"Building","text":"<p>The backend (core) application is packaged into a single binary, which references the built frontend files</p> <p>The frontend application is packaged into relevant build files utilizing Vite, output to the <code>/dist/frontend</code> directory.</p> <p>The backend application serves these files according to the logic defined within <code>/api/frontend/frontend.go</code></p> <p>After the backend build process completes, a Make <code>copier</code> is ran. This command copies the contents of <code>./dist/frontend</code> to all dist directories, enabling each compiled binary to reference the frontend files at their <code>./frontend</code></p> <p></p>"},{"location":"development/committing/","title":"Committing Code","text":"<p>We use Commitizen to standardize our commit messages according to Conventional Commits.</p> <p>Commits should be made against local feature branches, and pull requests should be created to merge changes into <code>main</code>.</p> <p></p>"},{"location":"development/committing/#make-a-commit","title":"Make a Commit","text":"<p>In order to make a commit, simply run:</p> <pre><code>make commit\n</code></pre>"},{"location":"development/deploying/","title":"Deploying","text":""},{"location":"development/environment/","title":"Development Environment","text":"<p>Relevant Decision Ref: ADR-00008</p> <p></p> <ul> <li>Nginx: Proxy &amp; Load Balancer enabling container communication and routing</li> <li>App: Compiled Go backend application container</li> <li>Database: Postgres container</li> <li>Prometheus: Metrics collection and storage</li> <li>Jaeger: Tracing collection and storage</li> <li>Mkdocs: Documentation site container</li> </ul>"},{"location":"development/environment/#utilizing-the-dev-environment","title":"Utilizing The Dev Environment","text":"<pre><code>make compose # builds, deploys, and runs development environment\n</code></pre> <p>Configuration files for the development environment are located in the deploy/compose directory</p> <p>The <code>make compose</code> command targets the <code>deploy/compose/docker-compose.yml</code> file, which includes the relevant service definitions for the development environment</p> <pre><code>deploy/compose/\n\u2502   \n\u251c\u2500\u2500 app # application layer\n\u2502   \u2514\u2500\u2500 docker-compose.\n\u2502   \n\u251c\u2500\u2500 database # database layer\n\u2502   \u2514\u2500\u2500 docker-compose.postgres.yml\n\u2502   \n\u251c\u2500\u2500 docs # documentation layer\n\u2502   \u2514\u2500\u2500 docker-compose.docs.yml\n\u2502   \n\u251c\u2500\u2500 network # network layer\n\u2502   \u2514\u2500\u2500 docker-compose.nginx.yml\n\u2502   \n\u251c\u2500\u2500 observability # observability layer\n\u2502   \u251c\u2500\u2500 docker-compose.jaeger.yml\n\u2502   \u2514\u2500\u2500 docker-compose.prometheus.yml\n\u2502 \n\u2514\u2500\u2500 docker-compose.yml # main compose file that ties everything together\n</code></pre>"},{"location":"development/releasing/","title":"Releasing","text":"<p>ADR-00002 outlines our release strategy.</p> <p>Upon merge to <code>main</code>, releases are automatically managed and orchestrated via Github Actions, utilizing GoReleaser for building and packaging releases, Commitizen for versioning and changelog generation.</p>"},{"location":"development/resources/","title":"Awesome Resources","text":"<ul> <li>Awesome Go - Awesome Go repo</li> <li>Awesome Vue - Awesome Vue repo</li> <li>Awesome AZD - Awesome Azure Azd repo</li> <li>Go By Example - Various Go basics with easy to follow implementation examples</li> <li>Go Seed - Bare bones Go project with OOTB Goreleaser pipelines and useful makefile</li> <li>Go Clean Template</li> <li>Sklinkert Go-DDD - a similar DDD boilerplate in go, however it does not currently implement <code>context.Context</code>, relies on separate validated entity structs within the domain layer, and lacks much of the additional boilerplate functionality</li> </ul>"},{"location":"development/resources/#docs-sites","title":"Docs Sites","text":"<ul> <li>vue</li> <li>Go</li> <li>GoReleaser</li> <li>OapiCodeGen</li> <li>vite</li> <li>tailwind</li> <li>daisyui</li> <li>golang-migrate</li> <li>sqlc</li> <li>chi</li> <li>opentelemetry</li> <li>postgres</li> <li>jaeger</li> <li>docker</li> <li>docker compose</li> <li>azure azd</li> <li>azure container apps</li> <li>azure bicep</li> <li>golangci-lint</li> <li>gofumpt</li> <li>commitizen</li> <li>Make (Makefile)</li> <li>Knip</li> <li>ESLint</li> <li>mkdocs</li> <li>Material for Mkdocs</li> <li>mockery</li> <li>pnpm</li> <li>uv</li> </ul>"},{"location":"development/resources/#ui-design-resources","title":"UI Design Resources","text":"<ul> <li>daisyui - Many readily available pre-built components.</li> <li>TailwindFlex - A collection of free Tailwind CSS components and templates.</li> </ul>"},{"location":"development/testing/","title":"Testing","text":""},{"location":"development/tools/","title":"Development Tools","text":""},{"location":"development/tools/#azure-developer-cli-azd","title":"Azure Developer CLI (azd)","text":"<p>Documentation: Azure Developer CLI (azd)</p>"},{"location":"development/tools/#commitizen","title":"Commitizen","text":"category detail Documentation Commitizen System Context Project Purpose Standardizing commit messages according to Conventional Commits Configuration .cz.yaml Usage Run <code>make commit</code> to create a commit with a standardized message"},{"location":"development/tools/#docker","title":"Docker","text":"category detail Documentation docker System Context Project Purpose Containerization of the application Configuration build/docker/Dockerfile Usage"},{"location":"development/tools/#docker-compose","title":"Docker Compose","text":"category detail Documentation docker compose System Context Project Purpose Development environment orchestration Configuration deploy/compose/ Usage <code>make compose</code>"},{"location":"development/tools/#eslint","title":"ESLint","text":"category detail Documentation ESLint System Context Frontend Purpose Linting for JavaScript/TypeScript code in the frontend application Configuration .eslintrc.json Usage <code>make lint-fe</code>"},{"location":"development/tools/#gofumpt","title":"GoFumpt","text":"category detail Documentation GoFumpt System Context Core / Backend Purpose Go code formatter, stricter than <code>gofmt</code> Configuration N/A Usage <code>make format</code>, <code>make format-be</code>"},{"location":"development/tools/#golangci-lint","title":"Golangci-lint","text":"category detail Documentation Golangci-lint System Context Core / Backend Purpose Go linting Configuration .golangci.yml Usage <code>make lint</code>, <code>make lint-be</code>"},{"location":"development/tools/#golang-migrate","title":"Golang-Migrate","text":"category detail Documentation golang-migrate System Context Core / Backend Purpose Database schema migrations Configuration migrations/ Usage"},{"location":"development/tools/#goreleaser","title":"GoReleaser","text":"category detail Documentation GoReleaser System Context Core / Backend Purpose Automation and orchestration of project releases Configuration .goreleaser.yml Usage"},{"location":"development/tools/#knip","title":"Knip","text":"category detail Documentation Knip System Context Frontend Purpose Identifying unused dependencies in the frontend application Configuration knip.config.js Usage <code>make deps</code>, <code>pnpm declutter</code>"},{"location":"development/tools/#make","title":"Make","text":"category detail Documentation Make (Makefile) System Context Project Purpose Automation &amp; Orchestration of common tasks and commands for project development Configuration Makefile Usage <code>make help</code> - displays all available make commands"},{"location":"development/tools/#mockery","title":"Mockery","text":"category detail Documentation mockery System Context Core / Backend Purpose Mock generation for Go interfaces Configuration mockery.yml Usage Run <code>make mock</code> to generate mocks for the Go interfaces"},{"location":"development/tools/#mkdocs-material-for-mkdocs","title":"MkDocs + Material for MkDocs","text":"category detail Documentation mkdocs, Material for Mkdocs System Context Documentation Purpose Documentation site generation and theming Configuration mkdocs.yml Usage Run <code>make docs</code> to build the documentation site"},{"location":"development/tools/#oapicodegen","title":"OapiCodeGen","text":"category detail Documentation OapiCodeGen System Context Core / Backend Purpose Generating Go server and client code from OpenAPI 3.0 specifications Configuration cfg.yaml Usage <code>make gen-api-be</code>"},{"location":"development/tools/#openapi-generator-cli","title":"OpenAPI-Generator-Cli","text":"category detail Documentation OpenAPI-Generator-Cli System Context Frontend Purpose Generation of the typescript API client library to enable the consumption of REST APIs from OpenAPI specifications Configuration openapi-generator-config.json Usage <code>make gen-api-fe</code>"},{"location":"development/tools/#prettier","title":"Prettier","text":"category detail Documentation Prettier System Context Frontend Purpose Code formatter for consistent code style in the frontend application Configuration prettier.config.js Usage <code>make format-fe</code>"},{"location":"development/tools/#pnpm","title":"PNPM","text":"category detail Documentation pnpm System Context Frontend Purpose Package management for the frontend application Configuration package.json Usage"},{"location":"development/tools/#sqlc","title":"SQLC","text":"category detail Documentation sqlc System Context Core / Backend Purpose Generation of go code for database interaction from sql queries Configuration .sqlc.yaml Usage"},{"location":"development/tools/#uv","title":"UV","text":"category detail Documentation uv System Context Documentation Purpose Python environment and package management for the documentation site Configuration pyproject.toml Usage"},{"location":"development/tools/#vite","title":"Vite","text":"category detail Documentation vite System Context Frontend Purpose build tool for frontend Configuration vite.config.ts Usage"},{"location":"development/tools/#vitest","title":"Vitest","text":"category detail Documentation Vitest System Context Frontend Purpose Testing framework for the frontend application Configuration vite.config.ts Usage <code>make test-fe</code>"},{"location":"development/versioning/","title":"Versioning","text":"<p>We adhere to Semantic Versioning (SemVer)</p>"},{"location":"module_apps/","title":"Application Modules","text":""},{"location":"module_apps/#ping-pong","title":"Ping Pong","text":"<p>The Ping Pong module is a nonsense example module encapsulating the core functionality related to pinging and ponging.</p> <p>Concept:</p> <ul> <li>A user can ping the system, and the system will respond with a pong</li> <li>A user can pong the system, and the system will respond with a ping</li> </ul>"},{"location":"system/","title":"System Architecture","text":""},{"location":"system/#full-stack","title":"Full Stack","text":"<p>This project exemplifies a full stack system architecture inclusive of a frontend User Interface (UI), a backend Application Programming Interface (API) encompassing the core logic, and a data persistence layer.</p> <p></p>"},{"location":"system/#domain-driven-design","title":"Domain-Driven Design","text":"<p>This project adopts and adheres to the Domain-Driven Design approach. Our bounded contexts are implemented as modules within the system. Each module adheres to the principles and patterns outlined in DDD, including domain entities, infrastructure repositories, and application services. Module implementations enable loose coupling of system components and an ability to easily extract modules into their own services if necessary. Further, each module is designed to enable the system to implement inversion of control and dependency injection principles.</p>"},{"location":"system/#further-ddd-reading","title":"Further DDD Reading","text":"<ul> <li>DDD Reference</li> <li>DDD Burger: A good article, particularly referencing DDD in Go, that I think does a nice job reflecting the various layers as if we were building a hamburger.</li> </ul>"},{"location":"system/#modular-monolith","title":"Modular Monolith","text":"<p>ARE YOU KIDDING ME? WHERE ARE THE MICROSERVICES???? Yeah yeah yeah... well first and foremost, you could think of this project itself as a microservice... but more imporantly, that's not the intent of this project. This project intends to focus on developing a well formed full stack system in an easy to understand / learn / develop manner, and introducing microservices would exponentially complicate things. If you would prefer a series of microservices, you can easily separate the SPA and create a series of services leveraging this project as a starting point.</p> <p></p>"},{"location":"system/#layered-clean-architecture","title":"Layered Clean Architecture","text":"<p>Similar to Domain-Driven Design, we adopt the principles of Clean Architecture to ensure separation of concerns and maintainability. The system is structured into distinct layers, each with specific responsibilities:</p> <ul> <li>Domain Layer: Contains the core business logic and domain entities. This layer is independent of any external systems or frameworks.</li> <li>Application Layer: Contains application services that orchestrate domain logic and handle use cases.</li> <li>Interface Layer: Contains the API controllers and routes that handle incoming requests and responses.</li> <li>Infrastructure Layer: Contains implementations for data access, external services, and other infrastructure concerns</li> </ul> <p></p>"},{"location":"system/#mono-repo-project-layout-structure","title":"Mono Repo Project Layout / Structure","text":"<p>This project is intentionally structured as a monorepo to display how all of the various pieces of the system are stitched together. We can follow the logical flow of the system from frontend view all the way through the backend database queries and every layer in between.</p> <p>Given the core of the system is defined in Go, we adhere to commonly accepted Go project layout best practices with slight adaptations to suit our needs.</p> <ul> <li>Directory Structure Reference Point: https://github.com/golang-standards/project-layout</li> </ul> <p>Root Directory Layout:</p> <pre><code>\u251c\u2500\u2500 api # api\n\u251c\u2500\u2500 app # core application implementation\n\u251c\u2500\u2500 build # build files (dockerfiles)\n\u251c\u2500\u2500 cmd # primary commands for running the application\n\u251c\u2500\u2500 configs # configuration files\n\u251c\u2500\u2500 db # database code (migrations, queries, etc.)\n\u251c\u2500\u2500 deploy # deploy targets\n\u251c\u2500\u2500 docs # documentation site and content\n\u251c\u2500\u2500 examples # example code\n\u251c\u2500\u2500 internal # core logic\n\u251c\u2500\u2500 pkg # go packages, cross-cutting\n\u251c\u2500\u2500 test # e2e tests and test utilities\n\u251c\u2500\u2500 tools # tools for the project\n\u2514\u2500\u2500 vendor # vendor packages  https://go.dev/ref/mod#vendoring\n</code></pre>"},{"location":"system/#frontend-vue-layout","title":"Frontend Vue Layout","text":"<p>The frontend application is defined as an embedded SPA, written in Vue.js, the project layout for the frontend vue application follows the pattern defined here Vue Reference</p>"},{"location":"system/frontend_ui/","title":"Frontend User Interface (UI)","text":""},{"location":"system/frontend_ui/#frontend-user-interface","title":"Frontend / User Interface","text":"<p>ADR Ref: ADR-00005</p> <p>The Frontend (User Interface) is implemented as a Single-Page Application (SPA) developed in Vue. The frontend application code can be found in <code>/api/frontend</code> intentionally because following our goal to align the overall project to be semantic and idiomatic... the frontend web ui is really just an interface in the context of the overall system.</p> <p>The Vue application is compiled, then the compiled frontend is embedded within the Go application. this can be seen within <code>api/frontend/frontend.go</code>.</p> <p>Note: when Go compiles it looks for <code>.go</code> files and ignores anything else, therefore, the all of the Vue/Typescript/node_modules/etc. have no impact to Go compilation</p> <p>Vite is simply used for building and development.</p>"},{"location":"system/frontend_ui/#design-system","title":"Design System","text":"<p>ADR Ref: ADR-00006</p>"},{"location":"system/module/","title":"System Modules","text":"<p>As noted in ADR-00002, the system architecture adopts a modular monolith approach, adhering to principles of Domain-Driven Design (DDD).</p>"},{"location":"system/module/#module-structure","title":"Module Structure","text":"<p>Each system module is structured to encapsulate the various layers of the application, ensuring separation of concerns and maintainability. The typical structure of a module is as follows:</p>"},{"location":"system/module/#core-backend","title":"core / backend","text":"<pre><code>internal/DOMAIN_MODULE\n\u251c\u2500\u2500 api          # Interface Layer: API controllers and routes\n\u251c\u2500\u2500 app          # Application Layer: Application services and use cases\n\u251c\u2500\u2500 domain       # Domain Layer: Core business logic and domain entities\n\u251c\u2500\u2500 infra        # Infrastructure Layer: Data access and external services\n\u2514\u2500\u2500 DOMAIN_MODULE.go  # Module definition and entry point\n</code></pre>"},{"location":"system/module/#mock-implementations","title":"Mock Implementations","text":"<pre><code>test/mocks/DOMAIN_MODULE/\n</code></pre> <p>In order to configure the relevant mock implementations for use within tests, each system module will require updates to the <code>.mockery</code> configuration file to outline relevant system module packages.</p>"},{"location":"system/module/#frontend","title":"frontend","text":"<pre><code>api/frontend/src/DOMAIN_MODULE\n\u251c\u2500\u2500 __tests__   # Tests specific to the module\n\u251c\u2500\u2500 assets       # Assets specific to the module\n\u251c\u2500\u2500 components   # Vue components specific to the module\n\u251c\u2500\u2500 composables  # Vue composables specific to the module\n\u251c\u2500\u2500 configs      # Configuration files specific to the module\n\u251c\u2500\u2500 layouts      # Vue layouts specific to the module\n\u251c\u2500\u2500 router      # Vue router definitions specific to the module\n\u251c\u2500\u2500 services     # Services (API clients) specific to the module\n\u251c\u2500\u2500 stores        # Vuex store modules specific to the module\n\u251c\u2500\u2500 styles       # Styles specific to the module\n\u251c\u2500\u2500 utils       # Utility functions specific to the module\n\u251c\u2500\u2500 views        # Vue views specific to the module\n\u2514\u2500\u2500 DOMAIN_MODULE.ts  # Module definition and entry point\n</code></pre>"},{"location":"system/module/#rest-api","title":"REST API","text":"<pre><code>api/rest/DOMAIN_MODULE/{version}\n\u251c\u2500\u2500 client # Generated API client for the individual module version\n\u2502   \u251c\u2500\u2500 cfg.yaml # Configuration for the individual module version server\n\u2502   \u251c\u2500\u2500 client.gen.go # Generated client code for the individual module version\n\u2502   \u2514\u2500\u2500 generate.go # Code generation script for the individual module version\n\u251c\u2500\u2500 server # Generated API server for the individual module\n\u2502   \u251c\u2500\u2500 cfg.yaml # Configuration for the individual module version server\n\u2502   \u2514\u2500\u2500 generate.go # Code generation script for the individual module version\n\u2514\u2500\u2500 api.yaml # OpenAPI specification for the individual module version\n</code></pre>"},{"location":"system/module/#database","title":"Database","text":"<p>Note: Migration files must be defined within a consolidated <code>db/migrations/</code> directory to ensure proper execution order during migration runs.</p>"},{"location":"system/module/#migrations","title":"Migrations","text":"<pre><code>db/migrations/ # Database migration files\n</code></pre>"},{"location":"system/module/#queries-and-schemas","title":"Queries and Schemas","text":"<pre><code>db/DOMAIN_MODULE\n\u251c\u2500\u2500 queries  # Database query files specific to the module\n\u2514\u2500\u2500 schemas  # Database schema files specific to the module\n</code></pre> <p>Additionally, each system module will require updates to the corresponding <code>.sqlc</code> file to outline the relevant configuration.</p>"}]}